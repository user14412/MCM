### 1、目标：

+ 5月15日前完成论文初稿；
+ 尽快找老师交流一次，确认我对系统和论文的安排能够按时完成和通过答辩。

> 你要相信你能完成一件事，你才会开始去做这件事
>
> 如果在刚开始做的时候就能取得一些成就，你会比较容易地做下去



### 2、系统基本功能遗漏：

- [x] 首页
- [x] 新闻动态

- [x] 用户留言管理：对用户留言进行审核和发布。



### 3、关键技术概述：

**基本：**B/S 架构	  MVC 模式 	 **SpringBoot 框架** 	 **Vue 框架**	  

**前端：**Element-UI 框架	   bootstrap

**前端库：** **jwt验证/SpringSecurity**（登录注册）QuillEditor（文章编辑）pannellum（全景参观）Echarts 库	

**数据库：** **mysql数据库**

**持久层框架：**MyBatis 框架	**mybatis-plus**

**其他：**vue-router、vuex、jquery、axios、解决跨域问题



**降低AI率**

自己写，再让ai扩写，把扩写内容用自己的话写一遍。



DAO就是Mapper，DAO其实就是用来操作数据库的，封装所有对于数据库的数据CRUD操作，然后让业务层直接注入DAO对象，然后使用该方法即可

mybatis-plus把常见操作写进了BaseMapper，mapper类继承BaseMapper后就可以0SQL开发



MVC设计模式一般是：

View视图层 => Controller控制器层 => Service业务逻辑层 => DAO(Mapper)数据访问层



### 4、基本功能模块：

![image-20250505224339041](C:\Users\华为\AppData\Roaming\Typora\typora-user-images\image-20250505224339041.png)

**第一层是模块，下面属于该模块下支持的功能**



### 5、需求分析：

- [x] 需求分析
- [x] 系统建设目标
- [x] 业务需求分析

功能需求描述

确定业务参与者：参观者，管理员

用例词汇表（动词+名词）

用例建模

用例描述

非功能性需求分析

**A4的论文用B5的纸张作图可以使得图不会作的太大，文字不失真**

- [ ] 功能需求分析
  - [ ] 绘制用例图
- [ ] 非功能需求分析
- [ ] 可行性分析
  - [ ] 技术可行性（技术是否成熟、是否有特别棘手的难题）
  - [ ] 经济可行性


需求分析包括找到用户的真实需求，针对需求，设计功能；没有涉及到的也要另外写。

### 用例图

#### 关联

参与者与用例之间，指的是参与者可以做这件事，画法为用实线连接

#### 泛化

用例与用例之间，指的是一个父用例可以被特化为多个子用例，画法为子用例连实线空心箭头到父用例

买票 - 线上买票

​		- 线下买票

#### 包含

用例与用例之间，指的是一个用例包含其他用例所具有的行为，画法为基础用例连虚线<<include>>普通箭头箭头到被包含用例

登录 - 验证密码

#### 拓展

用例与用例之间，指的是一定条件下把新的行为加入到已有的用例中，画法为扩展用例连虚线<<extend>>普通箭头箭头到基础用例

登录 - 找回密码



### 系统设计

#### 功能模块设计

根据用例模型设计功能模块

模块名称命名习惯(名词+动词)

#### 基本动态模型（活动图）

#### 类的设计与实现（类图）

#### 数据库设计（E-R图）

#### 详细设计（动态建模时序图）





#### JWT

本后端项目采用 Spring Security 框架作为核心的安全解决方案，并结合 JWT（JSON Web Token）技术实现无状态的身份验证与授权机制。Spring Security 在项目中扮演着“安全守卫”的角色，通过一系列安全过滤器（如我们自定义的 `JwtAuthenticationTokenFilter`）拦截并处理每个HTTP请求，确保只有经过身份验证且拥有足够权限的用户才能访问受保护的资源。

在身份验证方面，项目并没有采用传统的基于 Session 的方式，而是选择了 JWT 这种轻量级的令牌机制。当用户成功完成登录（具体登录逻辑在 `/user/account/token/` 等接口实现）后，后端服务器会利用 `JwtUtil` 工具类生成一个 JWT 并返回给客户端。这个 JWT 就像一张临时的“身份凭证”，其中包含了用户的关键信息（例如用户ID，存储在 JWT 的 `subject` 字段中），并且通过预设的密钥进行签名，以防止篡改。

客户端在后续访问需要身份验证的接口时，会将 JWT 放置在 HTTP 请求头的 `Authorization` 字段中，格式为 "Bearer [token]"。我们自定义的 `JwtAuthenticationTokenFilter` 过滤器会拦截这些请求，并从请求头中提取 JWT。接着，该过滤器会调用 `JwtUtil` 的 `parseJWT` 方法解析 JWT，验证其有效性和签名。如果 JWT 有效，过滤器会从中提取用户ID，并根据这个ID查询数据库中的 `User` 信息（通过 `UserMapper`）。随后，`JwtAuthenticationTokenFilter` 会将该用户信息封装成 Spring Security 的 `Authentication` 对象，并将其设置到 Spring Security 的安全上下文 (`SecurityContextHolder`) 中，从而告知 Spring Security 当前用户已通过身份验证。

在授权方面，`SecurityConfig.java` 文件中配置了不同的访问策略。例如，`/images/**`, `/user/account/token/`, `/user/account/register/` 等接口被配置为允许所有用户访问 (`permitAll()`)，而其他大部分接口则需要用户通过身份验证 (`anyRequest().authenticated()`)。通过这种方式，Spring Security 结合 JWT 技术，实现了对后端API的安全保护，确保了数据的安全性和访问控制。项目采用无状态的 JWT 认证，减轻了服务器端的 Session 管理负担，并为未来的分布式部署提供了便利。
